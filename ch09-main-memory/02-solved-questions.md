# Chapter 9 — Fully Solved Questions (Main Memory)

All questions include complete answers/solutions, including numericals and “algorithmic steps”.

---

## A) Short Theory — Solved

### Q1) Differentiate logical and physical address.
**Answer:** A logical (virtual) address is generated by the CPU for a process, while a physical address is the real location in RAM after MMU translation.

### Q2) What is internal vs external fragmentation?
**Answer:**
- **Internal fragmentation:** unused space inside an allocated block (e.g., last page not full).
- **External fragmentation:** free memory exists but split into non-contiguous holes (common in variable partitions).

---

## B) Base/Limit Relocation — Fully Solved Numerical

### Q3) Base = 2000, Limit = 500. Find physical address for logical addresses 120, 499, 500.

**Rule:** if `LA < limit`, `PA = base + LA`, else trap.

- LA=120: 120 < 500 ✅ → PA = 2000 + 120 = **2120**
- LA=499: 499 < 500 ✅ → PA = 2000 + 499 = **2499**
- LA=500: 500 < 500 ❌ → **trap (addressing violation)**

---

## C) Paging Translation — Fully Solved Numerical

### Q4) Page size = 1 KB. Logical address = 2500 (decimal). Find (p,d).

**Solution:**
- Page size = 1024 bytes
- $p = \lfloor 2500 / 1024 \rfloor = 2$
- $d = 2500 \bmod 1024 = 452$

**Answer:** $(p,d) = (2, 452)$

### Q5) Page table: p2 → frame 5. Page size = 1 KB. Find physical address of LA=2500.

From Q4: (p,d)=(2,452), and p2→f5.

Physical address:
- base of frame 5 = $5 \times 1024 = 5120$
- PA = 5120 + 452 = **5572**

---

## D) Paging Internal Fragmentation — Fully Solved

### Q6) Process size = 10,000 bytes. Page size = 4096 bytes. How many pages and internal fragmentation?

**Solution:**
- Pages needed = $\lceil 10000/4096 \rceil = \lceil 2.441 \rceil = 3$ pages
- Allocated = $3 \times 4096 = 12288$ bytes
- Internal fragmentation = 12288 − 10000 = **2288 bytes**

---

## E) TLB / Effective Access Time (EAT) — Fully Solved

### Q7) Given: memory access time $m=100$ ns, TLB lookup $\varepsilon=10$ ns, hit ratio $h=0.8$. Compute EAT.

Model:
- Hit time = $\varepsilon + m = 10 + 100 = 110$ ns
- Miss time = $\varepsilon + 2m = 10 + 200 = 210$ ns

So:
$$EAT = 0.8(110) + 0.2(210) = 88 + 42 = 130\text{ ns}$$

**Answer:** **130 ns**

---

## F) Algorithms (Pseudocode) — Complete

### Q8) Algorithm: Base/limit address translation
```text
translate_base_limit(LA, base, limit):
  if LA >= limit:
    trap
  else:
    return base + LA
```

### Q9) Algorithm: Paging address translation using page table
Inputs: logical address LA, page size P, page table PT.

```text
translate_paging(LA):
  p = LA div P
  d = LA mod P
  f = PT[p]
  PA = f*P + d
  return PA
```

### Q10) Algorithm: TLB-assisted translation
```text
translate_with_TLB(p, d):
  if TLB contains p:
    f = TLB[p]
  else:
    f = PT[p]
    insert (p->f) into TLB
  return f*P + d
```

---

## G) Long Theory — Solved model answers

### Q11) Explain paging and why it removes external fragmentation.
**Answer:** Paging divides logical memory into fixed-size pages and physical memory into fixed-size frames. Processes occupy any available frames, so free memory does not need to be contiguous; therefore external fragmentation is eliminated. The tradeoff is overhead of page tables and possible internal fragmentation in the last page.

### Q12) Explain segmentation and its protection mechanism.
**Answer:** Segmentation divides a program into variable-sized logical units (code, data, stack). Each segment has a base and a limit. A logical address (s, d) is valid only if d < limit[s]; then the physical address is base[s] + d. This provides protection per segment.
